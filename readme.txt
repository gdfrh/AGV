"""
我想循环随机分配机器臂，将每次随机分配的结果作为解，function分别得出这种分配求得的能耗和时间，现在的问题是如何表示这个解，用编码？字典？
我现在调用任务是随机的，是否应该用固定的任务来查看配置的优先级
如果用编码的方式，那么比较容易进行最开始初始解以及第一代子代的构造，只需要变异（比如交换编码）然后提取到对应的生产单元，重新计算时间和能耗即可
字典不太好变异

1.7：接下来的问题：
1.引入时间改变状态，这里需要使用线程的方法解决，小车同理，订单同理
2.小车的变换与状态改变
3.循环套循环
4.现在订单是随机给的，是否需要修改
5.生产单元固定，是否需要修改
6.调度问题

"""


robot_arm中：
# 4. 现在回到闲置区等待小车的到来
这个会根据小车的数量来影响，所以这就是小车的因子
# wait_vga_time
而且这只能是一个一个订单的情况，如果有些订单路径不一样，那么还要考虑排队问题，等待时间会改变



我现在需要改变一下生产单元的方式：
遗传我是直接用一整个解进行交叉变异的2110000001111100001111110000000000010000011100000011111100000000000311000
按文档改变了之后，那样的话，机器臂的增减的消耗的逻辑也需要改变，不能用一个机器臂的消耗作为初始，而是要用每个生产区的最小生成机器臂数量作为初始，并且考虑增减的变化
遗传变异不能出现全0
交叉是否也要考虑？
变异中，还没考虑加，可以先sum来判断是否满足约束，如果等于总数，变异只考虑减法，如果小于总数概率考虑加减
如果全是第一前沿，也需要修改交叉的逻辑
初始化随机自身也不能重复
220000000020020020002000303000030000001000000010001000300030
300220002020000203020000300000200000000000000000000100000303
2030020000003000000320000030000000200000000000000100030303
前导0的问题：从大到小排序，或者f"{merged_number:0{total_units}d}"


1.13现在的问题：变异还没写，初始的种群不能存在相同，有时候找不到新的成员陷入死循环
思考：车可以全局使用，只需要在变异的时候修改它的值即可，一个是分布方式，一个是状态
关于交叉：如果变异后序列长短不同，那对应的个数交换是否达不到预期？
关于变异：1、如果生产单元增加或者减少，序列长短就会变化，这样交叉时就得注意范围（已解决）
        2、而且我是使用反映射到生产单元的机器臂个数的，那在修改生产单元个数后，如何反映射（不知道生产单元的修改），这样初始化的时候个数不一样如何初始化（已解决）
我的想法：2、是否可以修改一个NSGA2的计算逻辑，改成每获得一个序列，就计算目标函数；或者写一个列表来记录生产单元的个数（列表存列表，或者列表存序列），然后每一代会重置这个列表
[[3,3,3,3,3,3,3],[]]像这种的列表,其他的原初始化不变，只改变object那里的初始化逻辑，让它读取新的生产单元列表再初始化
关于调度：1、首先是订单的顺序
        2、目的确定时，空闲生产单元的选取
        3、生产区目的不定（多项选择时），生产区的选择
        4、现在忽略了从开始到第一个生产区中间的任何操作，以及最后一个生产区到结束的任何操作

2.19：
订单问题：1.订单生成：现在的订单生成是都从某一个生产区开始，经过所有生产区，没有达成某些订单只需要部分生产区并且顺序可以不同，并且订单长度不一致

是否可以生成一个任务-机器的处理时间矩阵，表示每个任务在每台机器上的处理时间，这个矩阵是已知的，将任务设置为A B C...这样随机分配任务时，就可以直接用ABC当订单

        2.多个订单的调度：如果使用调度的话，所带来的时间与工作区状态的问题手动不太行？（现在经过过一个订单，每一步操作是时间到达了就完成了，如果是多个订单怎么做）
        3.现在所计算出来的都是一个订单的时间和功率并且是用了最多机器臂情况下的结果
        4.订单之间的顺序改变
        5.时间是累加计算的(已解决)
调度问题：ALNS算法还没有实现
BUG：在NSGA2算法中有时会出现种群不足以更新下一种群

两种调度方法
1.遗传内嵌套大邻域：每获得一组部署解，就改变订单来获得最好的订单排列 √
2.大邻域内嵌套遗传：对多种订单排序确定更好的部署

关于流程顺序：考虑设计权重来表示，当所需单元忙碌则权重增加，即将它远离
要设计订单哪些是可以变化的，哪些是可破坏的（比如B-C连在一起时可破坏）
应该在什么样的条件下对订单顺序修改，什么样的条件下对工艺流程进行修改？

用权重来设置选择的哪个空闲的生产单元
我还想加一个空闲时间的功率消耗
2.27
1.如何设计订单的流程，哪些可以改变
2.后悔修复算子

3.3
1.后悔修复算子使用时若遇到了相同的订单如何设置适应值
2.现在代码跑不动，是否需要优化function
3.优化问题：可视化分配
          NSGA2里面的最后一个function是否可以不要？

          现在使用了3个function，第一个是对代种群进行交叉变异前扩充种群：：：我想只计算不ALNS优化这开始的填充种群
                              第二个是对扩充完的种群获取下一代的排序
                              第三个是每十代的输出：：：这里面是否可以直接用2里面的输出来，不用再算一遍了


3.13还是要解决一下解的多样性问题，经常跑不出来
3.14:
File "D:\AGV\robot_arm.py", line 268, in order_time_and_power
    min_unit_index, min_wait_time = self.find_min_wait_time(start_zone,'unit')
TypeError: cannot unpack non-iterable NoneType object，函数返回None，可能是time.time()的问题
需要修改一下操作的流程，现在是顺序优先级，如果一个后到的订单它先结束了某一步，会发现前面的订单占据了前面的位置，延长了等待。
但是你的所有订单选的都是最多机器臂的最快的，不可能出现后面的订单先做完，除非是流程不一样

空闲生产区的选择问题,现在是选机器臂最多的生产单元

如果机器臂是二位数，会导致储存问题特别是x0,现在的存储方式是int数字，无法判断是否是二位数，而且现在的判断方式是找0，所以二位数有问题需要限制或修改
以及对机器臂增减的参数设计（机器臂不能是多位数）

3.17：现在在修改流程
1.时间节点使用替换，可以知道是哪个订单的哪一个生产区(使用矩阵判断None),但是不知道是哪一个生产单元
2.还需要对小车的使用进行时间节点构造
3.使用矩阵按列这样计算，如果目的是同一生产区，那么优先级就不符合订单顺序（只需要改变矩阵遍历的顺序，改成先行后列即可）

3.18
1.参数设计
2.生产单元选择的权重设计
3.机器臂多位数
4.小车时间节点构造:
你得考虑起始点和结束点之间的小车的运送问题
    point_type, idx = time_line.get_next_point()
TypeError: cannot unpack non-iterable NoneType object
[-3, inf, -2, inf, inf, inf, -2, -3, -3, -3]
[(None, None, None, None), (None, None, None, None),
 (inf, '包装区', 1, 9, 2), (None, None, None, None),
 (None, None, None, None), (None, None, None, None),
 (inf, '喷漆区', 1, 7, 6), (inf, '包装区', 1, 8, 7),
 (None, None, None, None), (inf, '包装区', 1, 0, 9),
 (None, None, None, None), (None, None, None, None),
 (None, None, None, None), (None, None, None, None),
 (None, None, None, None)]
 相互死锁
 [inf, -3, inf, inf, inf, inf, inf, inf, inf, inf]
 决定简化车送到就走
    self.agv_states[obj_zone][idx_of_states] = False
IndexError: list assignment index out of range
5.交叉变异逻辑修改
6.把点画在一张图上


简化可以解决死锁?
[inf, -2, inf, inf, inf, inf, inf, inf, inf, inf]
[(None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None), (None, None, None, None)]

问题似乎是因为point的判定，没有考虑到多个相同的时间断点，所以现在似乎没有问题了
3.25
1.ALNS的订单选取问题，每一次解要在原有的订单顺序中修改