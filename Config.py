# map配置

map_rows = 15  # 地图的宽
map_cols = 39  # 地图的长
map_fill_char = ' '

# ------------------------
# 车间配置
road_width = 1  # 道路宽度

# 生产区墙壁位置
work_width_up = [11, 17, 30, map_cols-1]  # 上部墙壁
work_width_down = [15, 33, map_cols-1]  # 下部墙壁

# 生产区集合A
work_name_up = ['铸造区', '清洗区', '组装区', '配置区']
work_name_down = ['焊接区', '喷漆区', '包装区']
work_name = work_name_up + work_name_down
work_name_order = {  # 用来处理订单对应输出
    0: "铸造区",
    1: "清洗区",
    2: "组装区",
    3: "配置区",
    4: "焊接区",
    5: "喷漆区",
    6: "包装区"

}
"""生产区处理时间"""
# 制定生产区处理时间矩阵，行为生产区，列为机器臂个数
processing_time_matrix = [
    # 1   2   3   4   5   6   7   8   （机器臂个数）
    [50, 40, 32, 26, 21, 17, 14, 12, 11],  # 铸造区
    [60, 50, 42, 35, 29, 24, 20, 17, 16],  # 清洗区
    [70, 60, 52, 45, 39, 34, 30, 27, 25],  # 组装区
    [30, 25, 21, 18, 15, 13, 11, 10,  9],  # 配置区
    [20, 16, 13, 11,  9,  7,  6,  5,  4],  # 焊接区
    [90, 75, 63, 54, 47, 41, 36, 32, 31],  # 喷漆区
    [30, 25, 21, 18, 15, 13, 11, 10,  9],  # 包装区

]
energy_consumption_matrix = [
    # 1     2     3     4     5     6     7     8     9（机器臂个数）
    [4.0,  4.8,  5.5,  6.1,  6.6,  7.0,  7.3,  7.5,  7.6],  # 铸造区：中等能耗，递减增量适中
    [4.5,  5.4,  6.2,  6.9,  7.5,  8.0,  8.4,  8.7,  8.8],  # 清洗区：能耗与处理时间正相关
    [5.0,  6.0,  6.8,  7.4,  7.9,  8.3,  8.6,  8.8,  8.9],  # 组装区：初始能耗高，增速减缓明显
    [2.5,  3.0,  3.5,  4.0,  4.5,  5.0,  5.5,  6.0,  6.3],  # 配置区：线性递增，体现稳定负载
    [1.5,  1.8,  2.1,  2.4,  2.7,  3.0,  3.3,  3.6,  3.8],  # 焊接区：精细化操作，能耗增幅小
    [8.0,  9.0,  9.8, 10.5, 11.1, 11.6, 12.0, 12.3, 12.5],  # 喷漆区：高能耗但增速递减显著
    [2.0,  2.4,  2.7,  3.0,  3.3,  3.6,  3.9,  4.2,  4.3],  # 包装区：低能耗且增速稳定
]

# 生产区距离矩阵
# 假设这是一个已知的距离矩阵（单位：米）
distance_matrix = [
    [0,  10, 20, 30, 40, 50, 60, 70],  # 铸造区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [10,  0, 15, 25, 35, 45, 55, 50],  # 清洗区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [20, 15,  0, 10, 20, 30, 40, 60],  # 组装区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [30, 25, 10,  0, 10, 20, 30, 30],  # 配置区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [40, 35, 20, 10,  0, 10, 20, 20],  # 焊接区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [50, 45, 30, 20, 10,  0, 10, 90],  # 喷漆区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [60, 55, 40, 30, 20, 10,  0, 10],  # 包装区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
    [70, 50, 60, 30, 20, 90, 10,  0],  # 离开区 -> [铸造区, 清洗区, 组装区, ...,离开车间]
]

# ------------------------
# 机器臂配置
total_machines = 40  # 总机器数

# 存储机器臂的分配
machine_count_list = []  # 列表
# machine_counts = []  # 解的机器臂分配
energy_counts = []  # 解的能量消耗
time_counts = []  # 解的时间消耗
# 生产区机器臂的生产单元最低所需的数量最低要求
zone_requirements = [
    ("铸造区", 5),  # 铸造区生产单元需要5个机器臂
    ("清洗区", 3),  # 清洗区生产单元需要4个机器臂
    ("组装区", 3),  # 组装区生产单元需要5个机器臂
    ("配置区", 2),  # 配置区生产单元需要2个机器臂
    ("焊接区", 4),  # 焊接区生产单元需要3个机器臂
    ("喷漆区", 3),  # 喷漆区生产单元需要3个机器臂
    ("包装区", 3),  # 包装区生产单元需要4个机器臂
]
# ------------------------
# 小车配置
total_agv = 10  # 总车辆数
agv_speed = 2    # 小车速度

# ------------------------
# NSGA-II 参数
pop_size = 10  # 每一代种群数量
max_gen = 1  # 最高代数
number_limits = 0.5  # 交叉变异对象的数量需求
mutation_probability = 0.2  # 变异概率
# ------------------------
# 订单数
num_orders = 9
# 订单相似破坏率
similarity_percent = 0.2
# ------------------------
# ALNS 迭代次数
iteration = 1
init_temperature = 100
# ------------------------
# 对比实验：
compare_number = 7
# compare = 0
# NSGA-III 参数
num_obj = 2  # 优化目标数量
divisions = 4  # 参考点分布密度
# 设置运行次数
num_runs = 10  # 你可以根据需要修改运行次数
# ALNS轮盘赌,初始都用[1,1,1]
# operators = [随机破坏修复， 后悔修复， 贪心修复]

# 0.default
# 1.ALNS 与 随机修改订单
# 2.NSGA2 与 随机修改部署
# 3.ALNS、NSGA2 与 双重随机
# 4.ALNS：贪心插入
# 5.ALNS：后悔插入
# 4和5都需要参数分析：去掉任意一种除随机算子以外的算子所得到的结果，制作成表格。呈现最优值、平均值、方差
# 6.NSGA-III 与 NSGA-II
